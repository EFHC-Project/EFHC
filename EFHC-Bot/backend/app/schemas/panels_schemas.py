# -*- coding: utf-8 -*-
# backend/app/schemas/panels_schemas.py
# =============================================================================
# Назначение кода:
# Pydantic-схемы для раздела «Панели»: карточки панелей, курсорные страницы,
# вход/выход покупки панелей, служебные ответы синхронизации (догон генерации).
#
# Канон / инварианты:
# • Денежные/энергетические величины наружу — только строкой с 8 знаками.
# • Никаких «суточных» ставок — фронту отдаём только посекундные значения.
# • Покупка панели — ДЕНЕЖНАЯ операция: обязательный заголовок Idempotency-Key.
# • Лимит на пользователя — 1000 активных панелей (проверяется в сервисе).
# • Списание: сначала bonus_balance, затем main_balance (реализует сервис).
#
# ИИ-защиты:
# • Единые DTO для курсорной пагинации — CursorPage[PanelCard] из common_schemas.
# • Строгая форма входа покупки: quantity > 0, client_nonce для трассировки.
# • Служебный ответ синхронизации фиксирует сколько записей догнали и ошибки.
#
# Запреты:
# • В схемах НЕТ бизнес-логики и пересчётов, только форма данных.
# • Никаких P2P/внутренних трансферов — покупка идёт только через банк-сервис.
# =============================================================================

from __future__ import annotations

# =============================================================================
# Импорты
# -----------------------------------------------------------------------------
from typing import Any, Optional

from pydantic import BaseModel, Field, validator

from backend.app.schemas.common_schemas import (
    d8_str,
    CursorPage,
    OkMeta,
    BalancePair,
    PanelCard,
    IdempotencyContract,
)

# =============================================================================
# Витрина списков панелей (активные/архив) — курсорная пагинация
# -----------------------------------------------------------------------------
# Используем универсальную карточку и контейнер из common_schemas:
PanelsPage = CursorPage[PanelCard]

# =============================================================================
# Покупка панелей — вход/выход
# -----------------------------------------------------------------------------


class PanelPurchaseIn(IdempotencyContract):
    """
    Вход покупки панели(ей).
    ВАЖНО: это денежная операция — в роутере ОБЯЗАТЕЛЕН заголовок Idempotency-Key.

    Поля:
      • quantity — сколько панелей купить (целое > 0).
      • client_nonce — опциональный нонс для трассировки (наследуется).
    """

    quantity: int = Field(
        ..., gt=0, le=1000, description="Количество панелей к покупке (>0)"
    )


class PanelPurchaseOut(BaseModel):
    """
    Результат покупки панелей.

    Поля:
      • meta.ok / meta.server_time — служебная мета.
      • purchased — сколько панелей фактически куплено в этой операции.
      • total_active — итоговое число активных панелей у пользователя.
      • balances — итоговые балансы (main/bonus) строками с 8 знаками.
    """

    meta: OkMeta = Field(
        default_factory=OkMeta, description="Мета об успешной обработке"
    )
    purchased: int = Field(..., description="Сколько панелей куплено в этой операции")
    total_active: int = Field(
        ..., description="Итоговое число активных панелей у пользователя"
    )
    balances: BalancePair = Field(
        ..., description="Итоговые балансы (EFHC) после покупки"
    )


# =============================================================================
# Служебные ответы синхронизации (догон генерации по панелям)
# -----------------------------------------------------------------------------


class PanelsSyncOut(BaseModel):
    """
    Результат принудительной синхронизации (догон) генерации по панелям пользователя.

    Поля:
      • meta — служебная мета (ok, server_time).
      • backfilled — сколько панелей было догнано (пересчитано).
      • errors — сколько панелей/операций дали ошибку при догоне.
      • note — короткая текстовая пометка (например, "skip_locked", "partial").
    """

    meta: OkMeta = Field(default_factory=OkMeta)
    backfilled: int = Field(..., ge=0, description="Сколько панелей догнали")
    errors: int = Field(..., ge=0, description="Сколько ошибок возникло")
    note: Optional[str] = Field(None, description="Короткая приметка по результату")


# =============================================================================
# Дополнительные DTO (точечные карточки/агрегаты)
# -----------------------------------------------------------------------------


class PanelsSummaryOut(BaseModel):
    """
    Короткая сводка по панелям пользователя:
      • active_count — количество активных панелей,
      • total_generated_by_panels — суммарная генерация по панелям (кВт·ч), str(8),
      • nearest_expire_at — ISO-дата ближайшего истечения (или None).
    """

    active_count: int = Field(..., description="Число активных панелей")
    total_generated_by_panels: str = Field(
        ..., description="Суммарная генерация по панелям (кВт·ч), str(8)"
    )
    nearest_expire_at: Optional[str] = Field(
        None, description="ISO-дата ближайшего истечения срока"
    )

    @validator("total_generated_by_panels", pre=True)
    def _norm_q8(cls, v: Any) -> str:
        return d8_str(v)


# =============================================================================
# Пояснения:
# • PanelsPage = CursorPage[PanelCard] — единая форма листинга (items/next_cursor/etag).
# • Покупка панелей требует Idempotency-Key (в роутере проверяется заголовок).
# • Балансы всегда строкой с 8 знаками; числа-счётчики (quantity/total_active) — int.
# • Служебные ответы синхронизации помогают фронту показывать статус «догонянной»
#   генерации при открытии экрана «Панели».
# =============================================================================
