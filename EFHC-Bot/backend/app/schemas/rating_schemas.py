# -*- coding: utf-8 -*-
# backend/app/schemas/rating_schemas.py
# =============================================================================
# Назначение кода:
# Pydantic-схемы для раздела «Рейтинг»:
#  • единый формат строки рейтинга (позиция, пользователь, тотал kWh, флаги),
#  • «Я + TOP» витрина без дублирования «Я»,
#  • курсорная пагинация списков (без OFFSET),
#  • служебные модели для принудительного пересчёта/снапшотов.
#
# Канон/инварианты:
#  • Источник правды — total_generated_kwh пользователя (Decimal/8).
#  • Никаких «суточных» значений — только per-sec ставки в сервисах, здесь лишь чтение.
#  • Порядок выдачи: сначала «Я» с реальным местом, затем глобальный TOP-N,
#    причём «Я» не дублируется в TOP.
#  • Все суммы форматируются с точностью до 8 знаков (округление вниз).
#
# ИИ-защита:
#  • Централизованная квантизация Decimal через d8() из deps.py.
#  • Чёткая типизация и минимальные допуски по длинам/значениям.
#  • Модели не содержат полей, которые могут спровоцировать некорректные записи в БД.
#
# Запреты:
#  • Рейтинг не выдаёт и не обновляет балансы — он только читает агрегаты.
#  • Нет произвольной сортировки, только по total_generated_kwh (спад.).
#  • Нет сторонних «фильтров» и «перемешивания» — канон предписывает стабильный глобальный рейтинг.
# =============================================================================

from __future__ import annotations

from datetime import datetime
from decimal import Decimal
from typing import List, Optional

from pydantic import BaseModel, Field, conint, constr, validator

from backend.app.deps import d8
from backend.app.schemas.common_schemas import CursorPage


# =============================================================================
# Базовые DTO рейтинга
# =============================================================================

class RatingRowOut(BaseModel):
    """
    Строка рейтинга (один пользователь).
    position — место в глобальном рейтинге (1-based).
    total_generated_kwh — накопленная энергия (источник: users.total_generated_kwh).
    """
    position: conint(ge=1) = Field(..., description="1-based позиция в глобальном рейтинге.")
    user_tg_id: int = Field(..., description="Telegram ID пользователя.")
    username: Optional[constr(strip_whitespace=True, max_length=64)] = Field(
        None, description="Никнейм, если известен."
    )
    total_generated_kwh: Decimal = Field(..., description="Общее количество сгенерированных кВт·ч.")
    is_me: bool = Field(False, description="True, если это текущий пользователь.")

    @validator("total_generated_kwh", pre=True, always=True)
    def _q8(cls, v: Decimal) -> Decimal:
        return d8(v)

    class Config:
        json_encoders = {Decimal: lambda v: str(d8(v))}


class RatingPage(CursorPage[RatingRowOut]):  # type: ignore[type-arg]
    """
    Страница рейтинга с курсорной пагинацией.
    Важно: Роут/сервис обязан формировать курсор по устойчивому ключу (например, (score,id)).
    """
    items: List[RatingRowOut]


class MyPlusTopOut(BaseModel):
    """
    Витрина «Я + TOP». Сначала возвращается точная позиция текущего пользователя,
    затем срез глобального рейтинга TOP-N без дублирования «Я».
    """
    me: RatingRowOut
    top: List[RatingRowOut]
    # Курсор для догрузки следующих элементов TOP (если есть):
    next_cursor: Optional[str] = Field(None, description="Курсор для продолжения TOP-списка.")
    # Момент, на который построена витрина (снапшот):
    snapshot_at: datetime = Field(..., description="Временная метка вычисления (UTC).")


# =============================================================================
# Служебные входные модели (GET-query/админ-вызовы)
# =============================================================================

class RatingQueryIn(BaseModel):
    """
    Общая форма запроса рейтинга (может использоваться как query-модель).
    top_limit — желаемое количество записей в TOP после «Я».
    force_refresh — разрешение принудительно освежить кэш/снапшот (если доступно).
    """
    top_limit: conint(ge=1, le=100) = Field(100, description="Размер TOP-среза (1..100).")
    force_refresh: bool = Field(False, description="Принудительно обновить снапшот перед выдачей.")
    # Доп. параметр для курсора в списочных ручках:
    cursor: Optional[str] = Field(None, description="Курсор продолжения (если постраничная загрузка).")


class RatingSnapshotMetaOut(BaseModel):
    """
    Краткая метадата последнего снапшота/кэша рейтинга, чтобы UI понимал,
    нужно ли принудительное обновление.
    """
    snapshot_at: datetime
    item_count: int = Field(..., description="Сколько строк в кэше (для контроля полноты).")


# =============================================================================
# Админские входные модели (опционально для админ-ручек рейтинга)
# =============================================================================

class AdminRebuildRatingIn(BaseModel):
    """
    Админское задание на пересчёт рейтинга.
    Обычно запускается планировщиком каждые 10 минут, но можно инициировать вручную.
    """
    reason: Optional[constr(strip_whitespace=True, max_length=200)] = Field(
        None, description="Причина/комментарий для аудита."
    )
    # Жёсткое обновление даже при действующем валидном кэше:
    force: bool = Field(False, description="Игнорировать кэш и пересчитать заново.")


class AdminRebuildRatingOut(BaseModel):
    """
    Результат пересчёта рейтинга для админки.
    """
    ok: bool = True
    snapshot_at: datetime
    processed_users: int = Field(..., description="Количество пользователей, вошедших в расчёт.")
    duration_ms: int = Field(..., description="Время пересчёта в миллисекундах.")
    message: Optional[str] = None


# =============================================================================
# Пояснения «для чайника»:
# • Почему позиция 1-based?
#   Так привычнее для пользователей и согласовано с дизайном «место в рейтинге».
#
# • Почему курсоры?
#   Курсорная пагинация надёжнее OFFSET на больших объёмах и лучше дружит с ретраями:
#   клиент может безопасно повторять запросы и догружать «хвосты», не теряя порядок.
#
# • Где берётся total_generated_kwh?
#   Это агрегат из таблицы users.total_generated_kwh, который пополняет energy_service
#   (пер-сек ставки) и планировщик. В рейтинге никаких арифметик — только чтение и форматирование.
#
# • Что делает force_refresh?
#   Даёт сервису право освежить снапшот рейтинга (если кэш просрочен, неполон или отключён).
#   При нормальной работе рейтинг пересчитывается планировщиком каждые 10 минут.
# =============================================================================
